Що я хочу дізнатись?: Як робити операції між об'єктами та як настроїти поводження об'єкта при перетворенні в примітиви

Що я дізнався?: Перетворення об'єкту відбувається в випадках з математичними операціями, неявними перетвореннями, порівняннями.
Перетворення відбувається за таким алгоритмом:
  1. Спочатку викликається метод object[Symbol.toPrimitive(hint)] з хінтом одним з трьох значень: "string", "number", "default".
  2. В іншому випадку викликається спочатку .toString() якщо "string", спочатку .valueOf() якщо "number"/"default".

Як я це буду застосовувати в майбутньому?: При налагодженні(відкладці) програми щоб показати який об'єкт в данний момент часу. При операціях з об'єктами.

Що мене здивувало?: Мене здивувало що методи .toString() .valueOf() можуть повертати що завгодно. У такому випадку легко зробити гівнокод.

Схема преобразования обычных объектов в примитивы выглядит примерно так:
1) Логический:
Все объекты - true
2) Строковый:
Применяется toString() -> строка "[object Object]"
3) Числовой:
(а) нет метода valueOf(), использован оператор + -> [object Object]
(б) нет метода valueOf(), использованы операторы / * - % ** -> NaN
(в) есть метод valueOf() -> берется значение из него.

NaN получится только тогда, когда есть попытка "чистого" численного преобразования объекта (без +). К примеру, такие случаи:

{job: 'burglar'} * 10 // NaN
Number({job: 'burglar'})  //NaN

И унарный плюс:

+{job: 'burglar'}  // NaN

Унарный плюс- это отдельная песня. Он преобразует строку в число, если это возможно. В данном случае невозможно.

Теперь к примеру.

{} + "pimp"  // [object Object]pimp

Почему не NaN? Здесь случай (3.а) Такое сработает только для знака +, если взять другой арифметический оператор, то:

{} - "pimp"  // NaN

Получили NaN. Использован знак -, а это численное преобразование без всяких выкрутасов. И строка "pimp" не может преобразоваться к числу ни раком, ни боком , ни подскоком.